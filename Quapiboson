import numpy as np
import csv
import math
import matplotlib.pyplot as plt
from numpy.linalg import eig
from scipy.linalg import expm
from matplotlib.animation import FuncAnimation
from scipy.integrate import trapz

##DVR
def DVR(a,b,N,index,out):
    alpha=8
    beta=1
    charlie=0.01
    m=1
    hbar=1
    K=np.zeros((N,N),dtype='float')
    V=np.zeros((N,N),dtype='float')
    ii=np.linspace(a,b,N)
    Delx=(b-a)/N
    for i in enumerate(ii):
        for j in enumerate(ii):
            if i[0]==j[0]:
                V[i[0],j[0]]=-alpha*1/2*i[1]**2+beta*i[1]**4/4+charlie*i[1]
                K[i[0],j[0]]=hbar**2/(2*m*Delx**2)*(math.pi**2)/3
            else:
                K[i[0],j[0]]=hbar**2/(m*Delx**2)*(-1)**(i[0]-j[0])/(i[0]-j[0])**2
    eigen,eigf=eig(K+V)
    idx = np.argsort(eigen)
    eigen = eigen[idx]
    eigf = eigf[:,idx]
    return eigen[:index] if out ==0 else eigf
##Setup system
tarr = np.linspace(0.001,15000,num=25000)
T=1
ga=0.005
def J(x): #Spectral density
    return ga*x #Ohmic bath
def nb(o): #Bose occupation distribution
    return 1/(math.exp(o*T)-1)
def k(o): #Calculating real part of bath correlation function laplace transform
    if abs(o)<10**-3:
        return ga*T
    elif o<0:
        return J(abs(o))*nb(abs(o))
    else:
        return J(abs(o))*(nb(abs(o))+1)
    
#Hs=np.array([[0,0,0,0],[0,0,0,0],[0,0,1,0],[0,0,0,1]]) #System hamiltonian
steps=1001
xmin=-10
xmax=10
win=4
positions=np.linspace(xmin,xmax,steps)
thres=0
print(np.where(positions==thres))
Hs=np.diag(DVR(xmin,xmax,steps,win,0))
WFs=DVR(xmin,xmax,steps,win,1)
for index in np.linspace(0,win-1,win,dtype='int'):
    WFs[:,index]=WFs[:,index]/(trapz(abs(WFs[:,index])**2,positions[:]))**0.5
print(Hs)
n=len(Hs)

rhos=np.array([[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]])
rhot=np.zeros((n,n,len(tarr)),dtype = 'complex_')
Psit=np.zeros((steps,len(tarr)),dtype = 'complex_')
rhoDt=np.zeros((n,n,len(tarr)),dtype = 'complex_')
R=np.zeros((n,n,n,n),dtype = 'complex_')
DHs,V=eig(Hs)
Pp=np.zeros(len(tarr))
krp=np.zeros(len(tarr))
Ppd=np.zeros(len(tarr))
Cfs=np.zeros(len(tarr))
Pr=np.zeros(len(tarr))
Prd=np.zeros(len(tarr))
SL=np.array([[0,0,1,1],[0,0,1,1],[1,1,0,0],[1,1,0,0]]) #System coupling matrix
#SL=np.array([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]])
S=np.matmul(np.matmul(np.linalg.inv(V),SL),V)
rhosD=np.matmul(np.matmul(np.linalg.inv(V),rhos),V)
##Construct Liouvillian tensor
nn=np.linspace(0,n-1,n,dtype=np.int8)
for a in nn:
    for b in nn:
        R[a][b][a][b]=R[a][b][a][b]+1j*(DHs[a]-DHs[b])
        for c in nn:
            for d in nn:
                R[a,b,d,b]=R[a,b,d,b]-S[a,c]*S[c,d]*k(DHs[d]-DHs[c])/2
                R[a,b,a,c]=R[a,b,a,c]-S[b,d]*S[d,c]*k(DHs[c]-DHs[d])/2
                R[a,b,c,d]=R[a,b,c,d]+(S[d,b]*S[a,c]*k(DHs[c]-DHs[a])/2+S[c,a]*S[b,d]*k(DHs[d]-DHs[b])/2)
    
##Dynamics
L=np.reshape(R,(n**2,n**2))
print()
ithr=positions.tolist().index(thres)
print(ithr)
rhosv=np.reshape(rhosD,n**2)
for tin in enumerate(tarr):
    Lexp=expm(L*tin[1])
    rhoDt[0:,0:,tin[0]]=np.reshape(np.matmul(Lexp,rhosv),(n,n))
    rhot[0:,0:,tin[0]]=np.matmul(np.matmul(V,rhoDt[0:,0:,tin[0]]),np.linalg.inv(V))
    for index in np.linspace(0,win-1,win,dtype='int'):
        for index2 in np.linspace(0,win-1,win,dtype='int'):
            Psit[:,tin[0]]=Psit[:,tin[0]]+(rhot[index,index2,tin[0]])*np.multiply((WFs[:,index]),np.conjugate((WFs[:,index2])))
    #Psit[:,tin[0]]=Psit[:,tin[0]]/(trapz(abs(Psit[:,tin[0]]),positions[:]))**0.5
    Pr[tin[0]]=trapz((Psit[:ithr,tin[0]]),positions[:ithr])
    Pp[tin[0]]=1-Pr[tin[0]]
    if tin[0]>0:
        Ppd[tin[0]]=(Pp[tin[0]]-Pp[tin[0]-1])/(tarr[tin[0]]-tarr[tin[0]-1])
        Prd[tin[0]]=(Pr[tin[0]]-Pr[tin[0]-1])/(tarr[tin[0]]-tarr[tin[0]-1])
for tin in enumerate(tarr): 
    krp[tin[0]]=(Ppd[tin[0]])/(Pr[tin[0]]-Pp[tin[0]]*Pr[len(tarr)-1]/Pp[len(tarr)-1])
    Cfs[tin[0]]=trapz((-Prd[0:tin[0]]),tarr[0:tin[0]])
fig, ax = plt.subplots()
#ax[0].plot(tarr[1:2000], Pr[1:2000])
#ax[0].plot(tarr[1:2000], Pp[1:2000])         
ax.plot(tarr[1:5000],krp[1:5000])
#ax.plot(tarr[1:],krp[1:])
#ax.set_ylabel('Cff(t)/Cff(0)')
ax.set_xlabel('Time')
#ax.plot(tarr[1:2000],krp[1:2000]/P[])/
#ax[0].legend(['Pr', 'Pp'])
#ax[1].plot(Psit[:,2000])   
#ax[1].plot(tarr[1:2000], krp[1:2000])    
#ax[1].set_ylabel('k reactant to product')
#ax[1].set_xlabel('Time')
plt.show()

#plt.semilogx(np.linspace(0,len(tarr)-1,len(tarr),dtype=np.int8),tarr)

