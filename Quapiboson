
import numpy as np
import csv
import math
import torch as t
import matplotlib.pyplot as plt
from numpy.linalg import eig
from scipy.linalg import expm
from matplotlib.animation import FuncAnimation
from scipy.integrate import trapz
beta=0.25

kmax=4
N=50

ga=0.005
No=20
Inf=1
hbar=1
om=np.linspace(-5,25,No)
y=np.zeros(No,dtype = 'complex_')
yy=np.zeros(No,dtype = 'complex_')
tarr = np.linspace(0,10,num=N)
delt=(tarr[1]-tarr[0])/3
K=np.zeros((2,2,2,2),dtype = 'complex_')
L=np.zeros((2,2,2,2,N),dtype = 'complex_')
A=np.zeros((2,2,len(tarr)),dtype = 'complex_')
AA=np.zeros((2,2),dtype = 'complex_')
A[0,0,0]=1

Hs=np.array([[-1,1],[1,1]])
Ss=np.array([[1,0],[0,-1]])
#coupling is sigma z
DHs,V=eig(Ss)
DD=np.diag(DHs)
#A[:,:,0]=np.matmul(V,np.matmul(A[:,:,0],np.linalg.inv(V)))
#Hs=np.matmul(V,np.matmul(Hs,np.linalg.inv(V)))

def J(x): #Spectral density
    return np.pi/2*ga*x*np.exp(-abs(x)/2.5) #Ohmic bath
def nb(o): #Bose occupation distribution
    return 1/(np.exp(o*beta)-1)
def eta(kk,ll,t):
    l = min([kk, ll])
    k= max([kk,ll])
    if k == l:
        if 0<k<N:
            for iii in enumerate(om):
                yy[iii[0]]=1/(2*np.pi)*J(om[iii[0]])/(om[iii[0]]**2)*np.exp(beta*hbar*om[iii[0]]/2)/(math.sinh(beta*hbar*om[iii[0]]/2))*(1-np.exp(-1j*om[iii[0]]*delt))
        else:
            for iii in enumerate(om):
                yy[iii[0]]=1/(2*np.pi)*J(om[iii[0]])/(om[iii[0]]**2)*np.exp(beta*hbar*om[iii[0]]/2)/(math.sinh(beta*hbar*om[iii[0]]/2))*(1-np.exp(-1j*om[iii[0]]*delt/2))
            
    else:
        if 0<k<N:
            if l>0:
                for i in enumerate(om):
                    yy[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(math.sin(om[i[0]]*delt/2))**2*np.exp(-1j*om[i[0]]*delt*(k-l))
            else:
                for i in enumerate(om):
                    yy[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(math.sin(om[i[0]]*delt/4)**2)*(math.sin(om[i[0]]*delt/2)**2)*np.exp(-1j*om[i[0]]*(l*delt-delt/4))
            
        else:
            if l==0:
                for i in enumerate(om):
                    yy[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(math.sin(om[i[0]]*delt/4)**2)*np.exp(-1j*om[i[0]]*(t-delt/2))
            else:
                for i in enumerate(om):
                    yy[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(math.sin(om[i[0]]*delt/4)**2)*(math.sin(om[i[0]]*delt/2)**2)*np.exp(-1j*om[i[0]]*(t-l*delt-delt/4))
    return trapz(yy,om)
#for xp in enumerate(forpositions):
#            Inf=Inf*np.exp(-1/hbar*(xp[1]-backpositions[xp[0]])*(n(xp[0],xp[0],0)*xp[1]-np.conjugate(n(xp[0],xp[0],0))*backpositions[xp[0]]))
#for delk in np.linspace(1,steps-1,steps,dtype=np.int8):
#    Nmax=steps-delk
#    for xp in enumerate(forpositions[:Nmax]):
#        for xm in enumerate(backpositions[:Nmax]):
#            Inf=Inf*np.exp(-1/hbar*(forpositions[xp[0]+delk]-backpositions[xp[0]+delk])*(n(xp[0]+delk,xp[0],time)*xp[1]-np.conjugate(n(xp[0]+delk,xp[0],time))*backpositions[xp[0]]))
Inf=1
onetwo=np.linspace(-1/2,1/2,2,dtype='int')
onetwo[0]=Hs[0,0]
onetwo[1]=Hs[1,1]
TEO=expm(-1j*Hs*delt)
TEO2=expm(1j*Hs*delt)

def I(x1,x2,x3,x4,ii,jj,t):
    Sum=0
    for ii in np.linspace(0,3,4,dtype='int'):
        for jj in np.linspace(ii,3,3-ii+1,dtype='int'):
            for x1 in enumerate(onetwo): #forpositions is folded s+ and s-. Each is as long as the position grid
                for x2 in enumerate(onetwo):
                    for x3 in enumerate(onetwo): #forpositions is folded s+ and s-. Each is as long as the position grid
                        for x4 in enumerate(onetwo):
                            Sum=Sum-1/hbar*(x3[1]-x4[1])*(eta(ii,jj,t)*x1[1]-np.conjugate(eta(ii,jj,t))*x2[1])
                            
    return np.exp(Sum)
def Influence(x1,x2,x3,x4,ii,jj,t):
    Sum=-1/hbar*(x3-x4)*(eta(ii,jj,t)*x1-np.conjugate(eta(ii,jj,t))*x2)                
    return np.exp(Sum)
    #num of possible paths 2**timesteps
for tin in enumerate(tarr[:N-1]):
    for i in np.linspace(0,1,2,dtype='int'):
        for j in np.linspace(0,1,2,dtype='int'):
            T=0
            Inf=Influence(i,j,i,j,0,0,tin[1])
            for k in np.linspace(0,1,2,dtype='int'):
                for l in np.linspace(0,1,2,dtype='int'):
                    #T=T+TEO[i,k]*TEO2[l,j]*A[k,l,0]
                    for a in np.linspace(0,1,2,dtype='int'):
                        for b in np.linspace(0,1,2,dtype='int'):
                            Inf=Inf*Influence(i,j,a,b,delt,delt,tin[1])
                            for x in np.linspace(0,1,2,dtype='int'):
                                for y in np.linspace(0,1,2,dtype='int'):
                                    T=T+TEO[i,k]*TEO[k,a]*TEO[a,x]*A[x,y,tin[0]]*TEO2[y,b]*TEO2[b,l]*TEO2[l,j]*Inf
            
            A[i,j,tin[0]+1]=T
plt.figure()
plt.plot(tarr,A[0,0,:])
plt.plot(tarr,A[1,1,:])
print(A[0,0,:]+A[1,1,:])
plt.show() 
