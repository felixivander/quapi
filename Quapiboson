import numpy as np
import csv
import math
import torch as t
import matplotlib.pyplot as plt
from numpy.linalg import eig
from scipy.linalg import expm
from matplotlib.animation import FuncAnimation
from scipy.integrate import trapz
beta=5
N=200
kmax=3
ga=0.1*np.pi/2
No=120
Inf=1
hbar=1
om=np.linspace(-5,25,No)
y=np.zeros(No,dtype = 'complex_')
yy=np.zeros(No,dtype = 'complex_')
tarr = np.linspace(0,15,num=N)
delt=(tarr[1]-tarr[0])
A=np.zeros((2,2,len(tarr)),dtype = 'complex_')
AA=np.zeros((2,2),dtype = 'complex_')
A[0,0,0]=1

Hs=np.array([[1,1],[1,-1]])
Ss=np.array([[1,0],[0,-1]])
#coupling is sigma z
DHs,V=eig(Hs)
DD=np.diag(DHs)
#A[:,:,0]=np.matmul(V,np.matmul(A[:,:,0],np.linalg.inv(V)))
#Hs=np.matmul(V,np.matmul(Hs,np.linalg.inv(V)))
kmax=3
def J(x): #Spectral density
    return ga*abs(x)*np.exp(-abs(x)/7.5) #Ohmic bath
def eta(kk,ll,t):
    l = min([kk, ll])
    k= max([kk,ll])
    if k == l:
        if 0<k<kmax:#eta_kk checked
            for iii in enumerate(om):
                yy[iii[0]]=1/(2*np.pi)*J(om[iii[0]])/(om[iii[0]]**2)*np.exp(beta*hbar*om[iii[0]]/2)/(math.sinh(beta*hbar*om[iii[0]]/2))*(1-np.exp(-1j*om[iii[0]]*delt))
        else: #eta_NN eta_00 checked
            for iii in enumerate(om):
                yy[iii[0]]=1/(2*np.pi)*J(om[iii[0]])/(om[iii[0]]**2)*np.exp(beta*hbar*om[iii[0]]/2)/(math.sinh(beta*hbar*om[iii[0]]/2))*(1-np.exp(-1j*om[iii[0]]*delt/2))
            
    else:
        if 0<k<kmax:
            if l>0: #eta_kk' checked
                for i in enumerate(om):
                    yy[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*((math.sin(om[i[0]]*delt/2))**2)*np.exp(-1j*om[i[0]]*delt*(k-l))
            else: #eta_k0  checked
                for i in enumerate(om):
                    yy[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*((math.sin(om[i[0]]*delt/4)))*(math.sin(om[i[0]]*delt/2))*np.exp(-1j*om[i[0]]*(k*delt-delt/4))
            
        else:
            if l==0: #eta_N0 checked
                for i in enumerate(om):
                    yy[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*((math.sin(om[i[0]]*delt/4))**2)*np.exp(-1j*om[i[0]]*(t-delt/2))
            else: #eta_Nk'checked
                for i in enumerate(om):
                    yy[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(math.sin(om[i[0]]*delt/4))*(math.sin(om[i[0]]*delt/2))*np.exp(-1j*om[i[0]]*(t-l*delt-delt/4))
    return trapz(yy,om)
#for xp in enumerate(forpositions):
#            Inf=Inf*np.exp(-1/hbar*(xp[1]-backpositions[xp[0]])*(n(xp[0],xp[0],0)*xp[1]-np.conjugate(n(xp[0],xp[0],0))*backpositions[xp[0]]))
#for delk in np.linspace(1,steps-1,steps,dtype=np.int8):
#    Nmax=steps-delk
#    for xp in enumerate(forpositions[:Nmax]):
#        for xm in enumerate(backpositions[:Nmax]):
#            Inf=Inf*np.exp(-1/hbar*(forpositions[xp[0]+delk]-backpositions[xp[0]+delk])*(n(xp[0]+delk,xp[0],time)*xp[1]-np.conjugate(n(xp[0]+delk,xp[0],time))*backpositions[xp[0]]))
Inf=1
onetwo=[1,-1]
print(onetwo)
TEO=expm(-1j*Hs*delt)
TEO2=expm(1j*Hs*delt)

def Influence(x1,x2,x3,x4,ii,jj,t):
    Sum=-1/hbar*(x3-x4)*(eta(ii,jj,t)*x1-np.conjugate(eta(ii,jj,t))*x2)                
    return np.exp(Sum)
def Influencenull(x1,x2,ii):
    Sum=-1/hbar*(x1-x2)*(eta(ii,ii,0)*x1-np.conjugate(eta(ii,ii,0))*x2)                
    return np.exp(Sum)
    #num of possible paths 2**timesteps
for i in enumerate(onetwo):
        for j in enumerate(onetwo):
            T=0
            for k in enumerate(onetwo):
                for l in enumerate(onetwo):
                    Inf=Influence(k[1],l[1],i[1],j[1],0,0+1,tarr[0])*Influencenull(i[1],j[1],0)**2
                    T=T+TEO[i[0],k[0]]*A[k[0],l[0],0]*TEO2[l[0],j[0]]*Inf
            A[i[0],j[0],1]=T
for i in enumerate(onetwo):
        for j in enumerate(onetwo):
            T=0
            for m in enumerate(onetwo):
                for n in enumerate(onetwo):
                    for k in enumerate(onetwo):
                        for l in enumerate(onetwo):
                            Inf=Influence(k[1],l[1],i[1],j[1],0,1+1,tarr[0])*Influencenull(i[1],j[1],0)**3*Influence(m[1],n[1],i[1],j[1],1,1+1,tarr[0])*Influence(k[1],l[1],m[1],n[1],0,1,tarr[0])
                            T=T+TEO[i[0],m[0]]*TEO[m[0],k[0]]*A[k[0],l[0],0]*TEO2[l[0],n[0]]*TEO2[n[0],j[0]]*Inf
            A[i[0],j[0],2]=T
for tin in enumerate(tarr[:N-3]):
    for i in enumerate(onetwo):
        for j in enumerate(onetwo):
            T=0
            for k in enumerate(onetwo):
                for l in enumerate(onetwo):
                    #Inf=Inf*Influence(k,l,i,j,tin[0],tin[0]+1,tin[1])#*Influencenull(k,l,tin[0])
                    #T=T+TEO[i,k]*TEO2[l,j]*A[k,l,0]
                    for a in enumerate(onetwo):
                        for b in enumerate(onetwo):
                            #Inf=Inf*Influence(a,b,i,j,tin[0],tin[0]+2,tin[1])*Influence(a,b,k,l,tin[0],tin[0]+1,tin[1])#*Influencenull(a,b,tin[0])
                            #Inf=Inf*Influence(i,j,a,b,delt,delt,tin[1])
                            for x in enumerate(onetwo):
                                for y in enumerate(onetwo):
                                    Inf=Influence(a[1],b[1],i[1],j[1],1,3,3*delt)*Influence(a[1],b[1],k[1],l[1],0,1,1*delt)*Influence(x[1],y[1],i[1],j[1],0,3,delt*3)*Influence(x[1],y[1],a[1],b[1],0,1,delt)*Influence(x[1],y[1],k[1],l[1],0,2,delt*2)*Influencenull(x[1],y[1],tin[0])**4*Influence(k[1],l[1],i[1],j[1],2,3,delt)
                                    #print(Inf)
                                    #Inf=1
                                    T=T+TEO[i[0],k[0]]*TEO[k[0],a[0]]*TEO[a[0],x[0]]*A[x[0],y[0],tin[0]]*TEO2[y[0],b[0]]*TEO2[b[0],l[0]]*TEO2[l[0],j[0]]*Inf
            A[i[0],j[0],tin[0]+3]=T
plt.figure()
plt.plot(tarr,A[0,0,:]-A[1,1,:])
plt.plot(tarr,A[1,1,:])
plt.plot(tarr,A[0,0,:])
plt.xticks(np.arange(0, 15, step=0.2))
print(Hs)
print(A[0,0,:]+A[1,1,:])
Gibbs=expm(Hs*beta)
Gibbs=Gibbs/(Gibbs[0,0]+Gibbs[1,1])
plt.hlines(y=Gibbs[0,0], xmin=0, xmax=12.5, linewidth=2, color='r', linestyle='dashed')
plt.show() 
