
import numpy as np
import csv
import math
import torch as t
import matplotlib.pyplot as plt
from numpy.linalg import eig
from scipy.linalg import expm
from matplotlib.animation import FuncAnimation
from scipy.integrate import trapz
beta=0.4
alpha=4
charlie=0.001
bbb=1

kmax=9
N=250

ga=0.64
No=100
Inf=1
hbar=1
om=np.linspace(-5,25,No)
y=np.zeros(No,dtype = 'complex_')
tarr = np.linspace(0.001,30,num=N)
delt=tarr[2]-tarr[1]
K=np.zeros((2,2,2,2),dtype = 'complex_')
L=np.zeros((2,2,2,2,N),dtype = 'complex_')
A=np.zeros((2,2,len(tarr)),dtype = 'complex_')
AA=np.zeros((2,2),dtype = 'complex_')
A[0,0,0]=1

Hs=np.array([[-0,1],[1,0]])
Ss=np.array([[1,0],[0,-1]])
#coupling is sigma z
DHs,V=eig(Ss)
DD=np.diag(DHs)
#A[:,:,0]=np.matmul(V,np.matmul(A[:,:,0],np.linalg.inv(V)))
#Hs=np.matmul(V,np.matmul(Hs,np.linalg.inv(V)))

def J(x): #Spectral density
    return np.pi/2*ga*x*np.exp(-abs(x)/2.5) #Ohmic bath
def nb(o): #Bose occupation distribution
    return 1/(np.exp(o*beta)-1)
def n(kk,ll,t):
    l = min([kk, ll])
    k= max([kk,ll])
    if k == l:
        if 0<k<N:
            for i in enumerate(om):
                y[i[0]]=1/(2*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(1-np.exp(-1j*om[i[0]]*delt))
        else:
            for i in enumerate(om):
                y[i[0]]=1/(2*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(1-np.exp(-1j*om[i[0]]*delt/2))
            
    else:
        if 0<k<N:
            if l>0:
                for i in enumerate(om):
                    y[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(math.sin(om[i[0]]*delt/2)**2)*np.exp(-1j*om[i[0]]*delt*(k-l))
            else:
                for i in enumerate(om):
                    y[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(math.sin(om[i[0]]*delt/4)**2)*(math.sin(om[i[0]]*delt/2)**2)*np.exp(-1j*om[i[0]]*(l*delt-delt/4))
            
        else:
            if l==0:
                for i in enumerate(om):
                    y[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(math.sin(om[i[0]]*delt/4)**2)*np.exp(-1j*om[i[0]]*(t-delt/2))
            else:
                for i in enumerate(om):
                    y[i[0]]=2/(1*np.pi)*J(om[i[0]])/(om[i[0]]**2)*np.exp(beta*hbar*om[i[0]]/2)/(math.sinh(beta*hbar*om[i[0]]/2))*(math.sin(om[i[0]]*delt/4)**2)*(math.sin(om[i[0]]*delt/2)**2)*np.exp(-1j*om[i[0]]*(t-l*delt-delt/4))
    return trapz(y,om)
#for xp in enumerate(forpositions):
#            Inf=Inf*np.exp(-1/hbar*(xp[1]-backpositions[xp[0]])*(n(xp[0],xp[0],0)*xp[1]-np.conjugate(n(xp[0],xp[0],0))*backpositions[xp[0]]))
#for delk in np.linspace(1,steps-1,steps,dtype=np.int8):
#    Nmax=steps-delk
#    for xp in enumerate(forpositions[:Nmax]):
#        for xm in enumerate(backpositions[:Nmax]):
#            Inf=Inf*np.exp(-1/hbar*(forpositions[xp[0]+delk]-backpositions[xp[0]+delk])*(n(xp[0]+delk,xp[0],time)*xp[1]-np.conjugate(n(xp[0]+delk,xp[0],time))*backpositions[xp[0]]))
Inf=1
onetwo=np.linspace(-1/2,1/2,2,dtype='int')
#onetwo[0]=Hs[0,0]
#onetwo[1]=Hs[1,1]
for tin in enumerate(tarr[:kmax]):
    Inf=0
    TEO=expm(-1j*Hs*delt)
    TEO2=expm(1j*Hs*delt)
    for delk in np.linspace(0,tin[0],tin[0],dtype=np.int8):
        for x1 in enumerate(onetwo): #forpositions is folded s+ and s-. Each is as long as the position grid
            for x2 in enumerate(onetwo):
                Inf=np.exp(1/hbar*(x1[1]-x2[1])*(n(tin[0],tin[0],tin[1])*x1[1]-np.conjugate(n(tin[0],tin[0],tin[1]))*x2[1]))
                for x3 in enumerate(onetwo):
                    for x4 in enumerate(onetwo):
                        Inf=Inf*np.exp(1/hbar*(x3[1]-x4[1])*(n(tin[0],delk,tin[1])*x1[1]-np.conjugate(n(tin[0],delk,tin[1]))*x2[1]))
                        K[x1[0],x2[0],x3[0],x4[0]]=TEO[x3[0],x1[0]]*TEO2[x4[0],x2[0]]
                        L[x1[0],x2[0],x3[0],x4[0],delk]=K[x1[0],x2[0],x3[0],x4[0]]*Inf
        LL=np.reshape(L[:,:,:,:,delk],(4,4))
        AA=np.matmul(LL,np.reshape(A[:,:,delk],(4,1)))
        #print(AA)
        A[:,:,delk+1]=np.reshape(AA,(2,2))
    #for delk in np.linspace(0,N-kmax-1,N-kmax,dtype=np.int8):


for tin in enumerate(tarr[kmax:len(tarr)-1]):
    Inf=0
    TEO=expm(-1j*Hs*delt)
    TEO2=expm(1j*Hs*delt)
    for delk in np.arange(tin[0],tin[0]+kmax):
        print(delk)
        for x1 in enumerate(onetwo): #forpositions is folded s+ and s-. Each is as long as the position grid
            for x2 in enumerate(onetwo):
                Inf=np.exp(-1/hbar*(x1[1]-x2[1])*(n(tin[0],tin[0],tin[1])*x1[1]-np.conjugate(n(tin[0],tin[0],tin[1]))*x2[1]))
                for x3 in enumerate(onetwo):
                    for x4 in enumerate(onetwo):
                        Inf=Inf*np.exp(-1/hbar*(x3[1]-x4[1])*(n(tin[0],delk-tin[0],tin[1])*x1[1]-np.conjugate(n(tin[0],delk-tin[0],tin[1]))*x2[1]))
                        K[x1[0],x2[0],x3[0],x4[0]]=TEO[x3[0],x1[0]]*TEO2[x4[0],x2[0]]
                        L[x1[0],x2[0],x3[0],x4[0],delk]=K[x1[0],x2[0],x3[0],x4[0]]*Inf
        LL=np.reshape(L[:,:,:,:,delk],(4,4))
        AA=np.matmul(LL,np.reshape(A[:,:,delk],(4,1)))
        A[:,:,delk+1]=np.reshape(AA,(2,2))
    #for delk in np.linspace(0,N-kmax-1,N-kmax,dtype=np.int8):



plt.figure()
#plt.plot(tarr[:len(tarr)-2],A[0,0,:len(tarr)-2])
#plt.plot(tarr[:len(tarr)-2],A[1,1,:len(tarr)-2])
plt.plot(tarr[:len(tarr)-2],A[0,0,:len(tarr)-2]-A[1,1,:len(tarr)-2])
plt.show()
